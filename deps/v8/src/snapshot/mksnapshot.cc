// Copyright 2006-2008 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <errno.h>
#include <signal.h>
#include <stdio.h>

#include <iomanip>

#include "include/libplatform/libplatform.h"
#include "include/v8-initialization.h"
#include "src/base/platform/platform.h"
#include "src/base/platform/wrappers.h"
#include "src/base/sanitizer/msan.h"
#include "src/base/vector.h"
#include "src/codegen/assembler-arch.h"
#include "src/codegen/source-position-table.h"
#include "src/flags/flags.h"
#include "src/snapshot/context-serializer.h"
#include "src/snapshot/embedded/embedded-file-writer.h"
#include "src/snapshot/snapshot.h"
#include "src/snapshot/startup-serializer.h"
#define V8_INTL_SUPPORT 1
#define V8_ENABLE_WEBASSEMBLY 1

// combustion headers
#include "src/roots/roots.h"
#include "src/interpreter/bytecodes.h"

namespace {

class SnapshotFileWriter {
 public:
  void SetSnapshotFile(const char* snapshot_cpp_file) {
    snapshot_cpp_path_ = snapshot_cpp_file;
  }

  void SetStartupBlobFile(const char* snapshot_blob_file) {
    snapshot_blob_path_ = snapshot_blob_file;
  }

  void WriteSnapshot(v8::StartupData blob) const {
    // TODO(crbug/633159): if we crash before the files have been fully created,
    // we end up with a corrupted snapshot file. The build step would succeed,
    // but the build target is unusable. Ideally we would write out temporary
    // files and only move them to the final destination as last step.
    v8::base::Vector<const i::byte> blob_vector(
        reinterpret_cast<const i::byte*>(blob.data), blob.raw_size);
    MaybeWriteSnapshotFile(blob_vector);
    MaybeWriteStartupBlob(blob_vector);
  }

 private:
  void MaybeWriteStartupBlob(
      const v8::base::Vector<const i::byte>& blob) const {
    if (!snapshot_blob_path_) return;

    FILE* fp = GetFileDescriptorOrDie(snapshot_blob_path_);
    size_t written = fwrite(blob.begin(), 1, blob.length(), fp);
    v8::base::Fclose(fp);
    if (written != static_cast<size_t>(blob.length())) {
      i::PrintF("Writing snapshot file failed.. Aborting.\n");
      remove(snapshot_blob_path_);
      exit(1);
    }
  }

  void MaybeWriteSnapshotFile(
      const v8::base::Vector<const i::byte>& blob) const {
    if (!snapshot_cpp_path_) return;

    FILE* fp = GetFileDescriptorOrDie(snapshot_cpp_path_);

    WriteSnapshotFilePrefix(fp);
    WriteSnapshotFileData(fp, blob);
    WriteSnapshotFileSuffix(fp);

    v8::base::Fclose(fp);
  }

  static void WriteSnapshotFilePrefix(FILE* fp) {
    fprintf(fp, "// Autogenerated snapshot file. Do not edit.\n\n");
    fprintf(fp, "#include \"src/init/v8.h\"\n");
    fprintf(fp, "#include \"src/base/platform/platform.h\"\n\n");
    fprintf(fp, "#include \"src/snapshot/snapshot.h\"\n\n");
    fprintf(fp, "namespace v8 {\n");
    fprintf(fp, "namespace internal {\n\n");
  }

  static void WriteSnapshotFileSuffix(FILE* fp) {
    fprintf(fp, "const v8::StartupData* Snapshot::DefaultSnapshotBlob() {\n");
    fprintf(fp, "  return &blob;\n");
    fprintf(fp, "}\n\n");
    fprintf(fp, "}  // namespace internal\n");
    fprintf(fp, "}  // namespace v8\n");
  }

  static void WriteSnapshotFileData(
      FILE* fp, const v8::base::Vector<const i::byte>& blob) {
    fprintf(fp,
            "alignas(kPointerAlignment) static const byte blob_data[] = {\n");
    WriteBinaryContentsAsCArray(fp, blob);
    fprintf(fp, "};\n");
    fprintf(fp, "static const int blob_size = %d;\n", blob.length());
    fprintf(fp, "static const v8::StartupData blob =\n");
    fprintf(fp, "{ (const char*) blob_data, blob_size };\n");
  }

  static void WriteBinaryContentsAsCArray(
      FILE* fp, const v8::base::Vector<const i::byte>& blob) {
    for (int i = 0; i < blob.length(); i++) {
      if ((i & 0x1F) == 0x1F) fprintf(fp, "\n");
      if (i > 0) fprintf(fp, ",");
      fprintf(fp, "%u", static_cast<unsigned char>(blob.at(i)));
    }
    fprintf(fp, "\n");
  }

  static FILE* GetFileDescriptorOrDie(const char* filename) {
    FILE* fp = v8::base::OS::FOpen(filename, "wb");
    if (fp == nullptr) {
      i::PrintF("Unable to open file \"%s\" for writing.\n", filename);
      exit(1);
    }
    return fp;
  }

  const char* snapshot_cpp_path_ = nullptr;
  const char* snapshot_blob_path_ = nullptr;
};

char* GetExtraCode(char* filename, const char* description) {
  if (filename == nullptr || strlen(filename) == 0) return nullptr;
  ::printf("Loading script for %s: %s\n", description, filename);
  FILE* file = v8::base::OS::FOpen(filename, "rb");
  if (file == nullptr) {
    fprintf(stderr, "Failed to open '%s': errno %d\n", filename, errno);
    exit(1);
  }
  fseek(file, 0, SEEK_END);
  size_t size = ftell(file);
  rewind(file);
  char* chars = new char[size + 1];
  chars[size] = '\0';
  for (size_t i = 0; i < size;) {
    size_t read = fread(&chars[i], 1, size - i, file);
    if (ferror(file)) {
      fprintf(stderr, "Failed to read '%s': errno %d\n", filename, errno);
      exit(1);
    }
    i += read;
  }
  v8::base::Fclose(file);
  return chars;
}

v8::StartupData CreateSnapshotDataBlob(v8::Isolate* isolate,
                                       const char* embedded_source) {
  v8::base::ElapsedTimer timer;
  timer.Start();

  v8::StartupData result = i::CreateSnapshotDataBlobInternal(
      v8::SnapshotCreator::FunctionCodeHandling::kClear, embedded_source,
      isolate);

  if (i::FLAG_profile_deserialization) {
    i::PrintF("[Creating snapshot took %0.3f ms]\n",
              timer.Elapsed().InMillisecondsF());
  }

  timer.Stop();
  return result;
}

v8::StartupData WarmUpSnapshotDataBlob(v8::StartupData cold_snapshot_blob,
                                       const char* warmup_source) {
  v8::base::ElapsedTimer timer;
  timer.Start();

  v8::StartupData result =
      i::WarmUpSnapshotDataBlobInternal(cold_snapshot_blob, warmup_source);

  if (i::FLAG_profile_deserialization) {
    i::PrintF("Warming up snapshot took %0.3f ms\n",
              timer.Elapsed().InMillisecondsF());
  }

  timer.Stop();
  return result;
}

void WriteEmbeddedFile(i::EmbeddedFileWriter* writer) {
  i::EmbeddedData embedded_blob = i::EmbeddedData::FromBlob();
  writer->WriteEmbedded(&embedded_blob);
}

using CounterMap = std::map<std::string, int>;
CounterMap* counter_map_ = nullptr;

void MaybeSetCounterFunction(v8::Isolate* isolate) {
  // If --native-code-counters is on then we enable all counters to make
  // sure we generate code to increment them from the snapshot.
  //
  // Note: For the sake of the mksnapshot, the counter function must only
  // return distinct addresses for each counter s.t. the serializer can properly
  // distinguish between them. In theory it should be okay to just return an
  // incremented int value each time this function is called, but we play it
  // safe and return a real distinct memory location tied to every counter name.
  if (i::FLAG_native_code_counters) {
    counter_map_ = new CounterMap();
    isolate->SetCounterFunction([](const char* name) -> int* {
      auto map_entry = counter_map_->find(name);
      if (map_entry == counter_map_->end()) {
        counter_map_->emplace(name, 0);
      }
      return &counter_map_->at(name);
    });
  }
}

}  // namespace

// combustion export start
#define VAL(str) #str
#define TOSTRING(str) VAL(str)
// Make a FOREACH macro
#define FE_0(WHAT)
#define FE_1(WHAT, X) WHAT(X)
#define FE_2(WHAT, X, ...) WHAT(X) FE_1(WHAT, __VA_ARGS__)
#define FE_3(WHAT, X, ...) WHAT(X) FE_2(WHAT, __VA_ARGS__)
#define FE_4(WHAT, X, ...) WHAT(X) FE_3(WHAT, __VA_ARGS__)
#define FE_5(WHAT, X, ...) WHAT(X) FE_4(WHAT, __VA_ARGS__)
//... repeat as needed

#define GET_MACRO(_0, _1, _2, _3, _4, _5, NAME, ...) NAME
#define FOR_EACH(action, ...)                                                  \
  GET_MACRO(_0, __VA_ARGS__, FE_5, FE_4, FE_3, FE_2, FE_1, FE_0)               \
  (action, __VA_ARGS__)

#define TOSTRING_NS(X) TOSTRING(X)

const char* const roots[] = {
#define DECL(type, name, CamelName) TOSTRING(type), TOSTRING(name), TOSTRING(CamelName),
  ROOT_LIST(DECL)
#undef DECL

  "<end>",
  "<end>",
  "<end>"
};

const char* const opcodes[] = {
#define DECLARE_BYTECODE(Name, ImplicitRegisterUse, ...)                       \
  "OpcodeType." TOSTRING(Name), TOSTRING(ImplicitRegisterUse), FOR_EACH(TOSTRING_NS, __VA_ARGS__) "",  \
      "<next>",
  BYTECODE_LIST(DECLARE_BYTECODE)
#undef DECLARE_BYTECODE
  "<end>"
};

void replace_all(std::string& s,
                 std::string const& toReplace,
                 std::string const& replaceWith) {
  std::string buf;
  std::size_t pos = 0;
  std::size_t prevPos;

  // Reserves rough estimate of final size of string.
  buf.reserve(s.size());

  while (true) {
    prevPos = pos;
    pos = s.find(toReplace, pos);
    if (pos == std::string::npos) break;
    buf.append(s, prevPos, pos - prevPos);
    buf += replaceWith;
    pos += toReplace.size();
  }

  buf.append(s, prevPos, s.size() - prevPos);
  s.swap(buf);
}

int combustion_main()
{
  int idx = 0;
  printf("// roots\n");
  printf("public enum Root\n");
  printf("{\n");
  while (1) {
    if (roots[idx] == "<end>" || roots[idx + 1] == "<end>" ||
        roots[idx + 2] == "<end>")
      break;
		
    printf("    %s,\n", roots[idx + 2]);
    idx += 3;
  }
  printf("}\n");
  printf("\n");

  idx = 0;
  printf("// root type map\n");
  printf("public Dictionary<Root, string> RootTypeLookup = new Dictionary<Root, string>()\n");
  printf("{\n");
  while (1) {
    if (roots[idx] == "<end>" || roots[idx + 1] == "<end>" ||
        roots[idx + 2] == "<end>")
      break;
		
    printf("    { Root.%s, \"%s\" },\n", roots[idx + 2], roots[idx]);
    idx += 3;
  }
  printf("};\n");
  printf("\n");


  idx = 0;
  printf("// opcodes\n");
  printf("public enum OpcodeType\n");
  printf("{\n");
  std::string opcodeType("OpcodeType.");
  while (1) {
    if (opcodes[idx] == "<end>") break;

    std::string thisString = std::string(opcodes[idx]);
    if (thisString.find(opcodeType) != std::string::npos) {
      thisString = thisString.substr(opcodeType.size());
      printf("    %s,\n", thisString.c_str());
    }

    idx++;
  }
  printf("}\n");
  printf("\n");


  idx = 0;
  printf("// opcode infos\n");
  printf("private void CreateOpcodes()\n");
  printf("{\n");
  printf("    V(");
  while (1) {
    if (opcodes[idx] == "<end>") break;

    std::string thisString = std::string(opcodes[idx]);
    replace_all(thisString, "ImplicitRegisterUse::k", "ImplicitRegisterUse.");
    replace_all(thisString, "OperandType::k", "OperandType.");

    if (opcodes[idx + 1] == "<next>") {
      printf("%s", thisString.c_str());
      printf(");\n");
      idx += 2;
      if (opcodes[idx] != "<end>")
        printf("    V(");
    } else {
      if (opcodes[idx + 1] == "" && opcodes[idx + 2] == "<next>") {
        printf("%s", thisString.c_str());
        printf(");\n");
        idx += 3;
        if (opcodes[idx] != "<end>")
          printf("    V(");
      } else {
        printf("%s, ", thisString.c_str());
        idx++;
      }
    }
  }
  printf("}\n");

  return 0;
}
// combustion export end


int main(int argc, char** argv) {
  v8::base::EnsureConsoleOutput();

  // Make mksnapshot runs predictable to create reproducible snapshots.
  i::FLAG_predictable = true;

  // Print the usage if an error occurs when parsing the command line
  // flags or if the help flag is set.
  using HelpOptions = i::FlagList::HelpOptions;
  std::string usage = "Usage: " + std::string(argv[0]) +
                      " [--startup-src=file]" + " [--startup-blob=file]" +
                      " [--embedded-src=file]" + " [--embedded-variant=label]" +
                      " [--target-arch=arch]" +
                      " [--target-os=os] [extras]\n\n";
  int result = i::FlagList::SetFlagsFromCommandLine(
      &argc, argv, true, HelpOptions(HelpOptions::kExit, usage.c_str()));
  if (result > 0 || (argc > 3)) {
    i::PrintF(stdout, "%s", usage.c_str());
    return result;
  }

  if (argc >= 2 && strcmp(argv[1], "generate_combustion_info") != 0) {
    combustion_main();
    return 0;
  }

  i::CpuFeatures::Probe(true);
  v8::V8::InitializeICUDefaultLocation(argv[0]);
  std::unique_ptr<v8::Platform> platform = v8::platform::NewDefaultPlatform();
  v8::V8::InitializePlatform(platform.get());
#ifdef V8_SANDBOX
  if (!v8::V8::InitializeSandbox()) {
    FATAL("Could not initialize the sandbox");
  }
#endif
  v8::V8::Initialize();

  {
    SnapshotFileWriter snapshot_writer;
    snapshot_writer.SetSnapshotFile(i::FLAG_startup_src);
    snapshot_writer.SetStartupBlobFile(i::FLAG_startup_blob);

    i::EmbeddedFileWriter embedded_writer;
    embedded_writer.SetEmbeddedFile(i::FLAG_embedded_src);
    embedded_writer.SetEmbeddedVariant(i::FLAG_embedded_variant);
    embedded_writer.SetTargetArch(i::FLAG_target_arch);
    embedded_writer.SetTargetOs(i::FLAG_target_os);

    std::unique_ptr<char> embed_script(
        GetExtraCode(argc >= 2 ? argv[1] : nullptr, "embedding"));
    std::unique_ptr<char> warmup_script(
        GetExtraCode(argc >= 3 ? argv[2] : nullptr, "warm up"));

    i::DisableEmbeddedBlobRefcounting();
    v8::StartupData blob;
    {
      v8::Isolate* isolate = v8::Isolate::Allocate();

      MaybeSetCounterFunction(isolate);

      // Set code range such that relative jumps for builtins to
      // builtin calls in the snapshot are possible.
      i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
      size_t code_range_size_mb =
          i::kMaximalCodeRangeSize == 0
              ? i::kMaxPCRelativeCodeRangeInMB
              : std::min(i::kMaximalCodeRangeSize / i::MB,
                         i::kMaxPCRelativeCodeRangeInMB);
      v8::ResourceConstraints constraints;
      constraints.set_code_range_size_in_bytes(code_range_size_mb * i::MB);
      i_isolate->heap()->ConfigureHeap(constraints);
      // The isolate contains data from builtin compilation that needs
      // to be written out if builtins are embedded.
      i_isolate->RegisterEmbeddedFileWriter(&embedded_writer);

      blob = CreateSnapshotDataBlob(isolate, embed_script.get());

      // At this point, the Isolate has been torn down but the embedded blob
      // is still alive (we called DisableEmbeddedBlobRefcounting above).
      // That's fine as far as the embedded file writer is concerned.
      WriteEmbeddedFile(&embedded_writer);
    }

    if (warmup_script) {
      v8::StartupData cold = blob;
      blob = WarmUpSnapshotDataBlob(cold, warmup_script.get());
      delete[] cold.data;
    }

    delete counter_map_;

    CHECK(blob.data);
    snapshot_writer.WriteSnapshot(blob);
    delete[] blob.data;
  }
  i::FreeCurrentEmbeddedBlob();

  v8::V8::Dispose();
  v8::V8::DisposePlatform();
  return 0;
}
